# MATRIX STRATEGY IN GITHUB ACTIONS

# PART 1 — PROBLEM STATEMENT

Before matrix, imagine you want to test your application on:

Ubuntu
Windows
macOS

And also on:

Node 16
Node 18

Without matrix, you must create **separate jobs manually**, like this:

```
job1-ubuntu-node16
job2-ubuntu-node18
job3-windows-node16
job4-windows-node18
job5-macos-node16
job6-macos-node18
```

Each job needs duplicated steps:

```
steps:
  - checkout
  - install dependencies
  - run tests
```

Problems:

1. Repetitive YAML code
2. Hard to maintain
3. If steps change, you must update all jobs
4. High chance of mistakes
5. File becomes long and confusing
6. Adding new versions requires new jobs manually

This is time-consuming and error-prone.

To solve this, GitHub introduced **Matrix Strategy**.

============================================================

# PART 2 — WHAT IS MATRIX STRATEGY

Matrix lets you run **the same job multiple times automatically**, with different combinations of OS, versions, images, etc.

Instead of writing 10 jobs manually, you write one job with matrix values.

GitHub automatically expands combinations.

============================================================

# PART 3 — SIMPLE BASIC EXAMPLE

Example 1: Test on two OS

```
name: Matrix Test
on:
  workflow_dispatch:

jobs:
  test:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest]
    steps:
      - name: Print OS
        run: echo "Running on ${{ matrix.os }}"
```

Output:
Two jobs will run automatically
Job 1 → ubuntu-latest
Job 2 → windows-latest

============================================================

# PART 4 — SIMPLE TWO-AXIS EXAMPLE

Example 2: OS + Node Version

```
name: OS and Node Matrix
on:
  workflow_dispatch:

jobs:
  test:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest]
        node: [16, 18]
    steps:
      - name: Show values
        run: |
          echo "OS = ${{ matrix.os }}"
          echo "Node version = ${{ matrix.node }}"
```

Matrix expands to:
ubuntu + node16
ubuntu + node18
windows + node16
windows + node18

Total 4 parallel jobs.

============================================================

# PART 5 — MATRIX USE CASES WITH CLEAN EXAMPLES

## Use Case 1 — Multiple OS testing

```
matrix:
  os: [ubuntu-latest, windows-latest, macos-latest]
```

Example:

```
name: Multi OS
on:
  workflow_dispatch:

jobs:
  test:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
    steps:
      - run: echo "Testing on ${{ matrix.os }}"
```

Use case: cross-platform testing.

---

## Use Case 2 — Multiple language/runtime versions

```
matrix:
  python: [3.8, 3.9, 3.10]
```

Example:

```
name: Python Versions
on:
  workflow_dispatch:

jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python: [3.8, 3.9, 3.10]
    steps:
      - run: echo "Testing on Python ${{ matrix.python }}"
```

Use case: compatibility testing.

---

## Use Case 3 — OS + runtime combination

```
matrix:
  os: [...]
  node: [...]
```

Example:

```
name: OS + Node
on:
  workflow_dispatch:

jobs:
  test:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest]
        node: [16, 18]
    steps:
      - run: echo "$matrix.os $matrix.node"
```

Use case: testing app on multiple OS and versions.

---

## Use Case 4 — Using include (add special values)

```
include:
  - os: ubuntu-latest
    node: 18
    message: optimized-build
```

Example:

```
name: Matrix with Include
on:
  workflow_dispatch:

jobs:
  test:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest]
        node: [16, 18]
        include:
          - os: ubuntu-latest
            node: 18
            message: optimized-build
    steps:
      - run: |
          echo "OS ${{ matrix.os }}"
          echo "Node ${{ matrix.node }}"
          echo "Message ${{ matrix.message }}"
```

Use case: attach extra data to specific combinations.

---

## Use Case 5 — Using exclude (remove unwanted combinations)

Example:

```
name: Matrix with Exclude
on:
  workflow_dispatch:

jobs:
  test:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest]
        node: [14, 16, 18]
        exclude:
          - os: windows-latest
            node: 18
    steps:
      - run: echo "$matrix.os $matrix.node"
```

Use case: skip failure-prone or unsupported combos.

---

## Use Case 6 — Matrix with Docker images (based on your image)

```
matrix:
  os: [ubuntu-latest, ubuntu-20.04, windows-latest]
  images: [hello-world, alpine]
```

Example:

```
name: Docker Matrix
on:
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, ubuntu-20.04, windows-latest]
        images: [hello-world, alpine]
    steps:
      - name: Docker details
        run: docker info
      - name: Run image
        run: docker run ${{ matrix.images }}
```

Use case: testing Docker images across OS.

---

## Use Case 7 — Control parallel execution

Example:

```
strategy:
  max-parallel: 2
  fail-fast: false
```

Example workflow:

```
name: Parallel Control
on:
  workflow_dispatch:

jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      max-parallel: 2
      fail-fast: false
      matrix:
        version: [1,2,3,4,5]
    steps:
      - run: echo "Version = ${{ matrix.version }}"
```

Use case: limit runner load, run all jobs even if one fails.

---

## Use Case 8 — Using matrix for service containers (database)

Example:

```
name: DB Matrix
on:
  workflow_dispatch:

jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        db: [mysql:8, postgres:12]
    services:
      db:
        image: ${{ matrix.db }}
        ports:
          - 5432:5432
    steps:
      - run: echo "Testing DB ${{ matrix.db }}"
```

Use case: test app against multiple database versions.

============================================================

# PART 6 — SUMMARY

Matrix solves the problem of duplicated jobs.
It automatically runs one job multiple times with different values.
It supports include, exclude, services, caching, OS testing, runtime testing, Docker combinations, and parallelism control.

